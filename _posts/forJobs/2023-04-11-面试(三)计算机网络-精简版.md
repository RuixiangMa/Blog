---
categories: [forJobs]
tags: Interview Linux
---

# 写在前面

参考了小林的图解网络部分, 以及*网络是怎样连接的*. 

## 常见缩略词

### 协议部分

| 缩略词 |                全称                 |        含义        | 位置   | 作用                                                         |
| :----: | :---------------------------------: | :----------------: | ------ | ------------------------------------------------------------ |
|   IP   |          Internet Protocol          |     互联网协议     | IP 层  |                                                              |
|  MAC   |                                     |    媒体访问控制    |        |                                                              |
|        |                                     |                    |        |                                                              |
|  ARP   |      Address Resolve Protocol       |    地址解析协议    |        |                                                              |
|  RARP  |  Reverse Address Resolve Protocol   |   逆地址解析协议   |        |                                                              |
|  ICMP  |  Internet Control Message Protocol  | 互联网控制报文协议 | IP 层  | 确认 IP 包是否成功送达目标地址<br />报告发送过程中 IP 包被废弃的原因<br />改善网络设置等 |
|  TCP   |    Transmission Control Protocol    |    传输控制协议    | 传输层 |                                                              |
|  UDP   |       User Datagram Protocol        |   用户数据报协议   | 传输层 |                                                              |
|  HTTP  |     HyperText Transfer Protocol     |   超文本传输协议   | 应用层 |                                                              |
| HTTPS  | HyperText Transfer Protocol Secure  | 超文本安全传输协议 | 应用层 |                                                              |
|  DHCP  | Dynamic Host Configuration Protocol |  动态主机配置协议  | 应用层 | 使用 UDP 协议工作<br />用于内网或网络服务供应商自动分配IP地址给用户<br/>用于内网管理员对所有电脑作中央管理 |
|  SSH   |        Secure Shell Protocol        |    安全外壳协议    | 应用层 | 通过非对称加密实现身份验证                                   |
|  SMTP  |    Simple Mail Transfer Protocol    |  简单邮件传输协议  | 应用层 |                                                              |
|  POP3  |                                     |                    | 应用层 |                                                              |
|  FTP   |       File Transfer Protocol        |    文件传输协议    | 应用层 |                                                              |



### 数据包部分

| 缩略词 |                  含义                   |                             作用                             |
| :----: | :-------------------------------------: | :----------------------------------------------------------: |
|  MTU   | Maximum Transmission Unit(最大传输单元) |      规定了一个网络包的最大长度, 以太网一般是1500 字节       |
|  MSS   |   Maximum Segment Size(最大分段长度)    | MTU 减去 TCP 头部和 IP 头部后的大小<br />除去头部后, 一个网络包所能容纳的 TCP 数据的最大长度 |
|  SFD   |   Start Frame Delimiter(起始帧分界符)   |                             报头                             |
|  FCS   |    Frame Check Sequence(帧校验序列)     |                             报尾                             |
|  TTL   |              Time To Live               |                         报文生存时间                         |



### 应用部分

| 缩略词 | 含义                      | 作用           |
| ------ | ------------------------- | -------------- |
| DNS    | Domain Name System        | 域名(解析)系统 |
| HTML   | HyperText Markup Language | 超文本标记语言 |
|        |                           |                |



# 基本概念

## 一个网络包的组成

```c
|-----|----------|---------|----------|  ==>   MSS  <==  |-----|
| SFD | MAC head | IP head | TCP head |   ==> data <==   | FCS |
|-----|----------|---------|----------|------------------|-----|
|-----|----------|------==>  MTU(1500 Bytes)  <==--------|-----|
```



## 网络数据包的头部信息

添加IP 头部和 MAC 头部都是在 IP 层(网络层)完成的. 

>   无论要收发的包是控制包还是数据包, IP 对各种类型的包的收发操作都是相同的. 

### IP 头部 : IP 所需的头部, 包含 IP 地址

-   包含 IP 协议规定的, 根据 IP 地址将包发往目的地所需的控制信息

### MAC 头部 : 以太网所需的头部, 包含 MAC 地址

-   包含通过以太网的局域网将包传输至最近的路由器所需的控制信息



## socket

socket**实体**是一段保存 **通信控制信息** 的内存空间. 

协议栈在进行操作时需要参阅这些控制信息. 

创建套接字时, 首先分配一个套接字所需的内存空间, 然后向其中写入初始状态. 



## 连接

客户端向服务器传达开始通信的请求. 

本质上是通信双方交换控制信息, 在套接字中记录这些必要信息并准备数据收发的一连串操作. 

>   所交换的控制信息是根据通信规则来确定的, 只要根据规则执行连接操作, 双方就可以得到必要的信息从而完成数据收发的准备. 

### 步骤

1.   在 TCP 模块处创建表示连接控制信息的头部. 

     通过 TCP 头部中的发送方和接收方端口号可以找到要连接的套接字. 

## DNS 使用的协议

>   UDP, 可能会用到 TCP









# 传输层(TCP/UDP)

## 基本问题

为什么需要TCP?

>   `IP` 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。

为什么TCP传输是可靠的?

>   -   TCP协议采用**发送应答**机制, 即发送端发送的每个TCP报文段都必须得到接收方的应答, 才认为这个TCP报文段传输成功.
>   -   TCP协议采用**超时重传**机制, 发送端在发送出一个TCP报文段之后启动定时器, 如果在定时时间内未收到应答,将重发报文段.
>   -   TCP报文段最终是以IP数据报发送的, 而IP数据报到达接收端可能乱序/重复, 所以TCP协议还会对接收到的TCP报文段重排/整理, 再交付给应用层. 

什么是TCP的半关闭?

>   TCP连接是全双工的, 所以允许两个方向的数据传输被独立关闭, 也即通信的一段可以发送结束报文段给对方, 告诉它本端已经完成了数据的发送, 但允许继续接收来自对方的数据, 直到对方也发送结束报文段以关闭连接. 

什么时候发送复位(RST)报文段?

>   -   访问了不存在的端口
>   -   异常终止连接
>   -   处理半打开连接

### TCP超时重传

保证在网络异常情况下(出现超时或者丢包)的连接与传输

>   TCP服务必须能够重传超时时间内未收到确认的TCP报文段, 为此, TCP模块为每一个TCP报文段都维护了一个重传定时器, 该定时器在TCP报文段第一次被发送时启动. 
>
>   如果超时时间内未收到接收方的应答, TCP模块将重传TCP报文段并重置定时器. 

### TCP拥塞控制

>    提高网络利用率, 降低丢包率, 保证网络资源对每条数据流的公平性. 

>   1.   慢启动
>   2.   拥塞避免
>   3.   快速重传
>   4.   快速恢复



## 粘包/拆包



## TCP三次握手

（1）握手

- 第一次握手：主机A发送握手信号syn＝1和seq=x（随机产生的序列号）的数据包到服务器，主机B由SYN=1知道，A要求建立联机；

- 第二次握手：主机B收到请求后要确认联机信息，向A发送syn=1，ack=x（x是主机A的Seq）+1，以及随机产生的确认端序列号

seq=y的包；

- 第三次握手：主机A收到后检查ack是否正确（ack=x+1），即第一次发送的seq+1，若正确，主机A会再发送ack=y+1，以及随机序

列号seq=z，主机B收到后确认ack值则连接建立成功；

- 完成三次握手，主机A与主机B开始传送数据。

注：上述步骤中，第二和第三次确认包中都还包含一个标志位未予以说明，该标志位为1表示正常应答；

### 为什么需要“三次握手”？

>   “三次握手”的目的是“防止已失效的连接请求报文段(重复的历史连接)突然又传送到了服务端，因而产生错误”。
>
>   具体例如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。
>
>   假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。
>
>   采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。主要目的防止server端一直等待，浪费资源。



## TCP四次挥手

由于TCP连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。

(1) TCP客户端发送一个FIN，用来关闭客户到服务器的数据传送(报文段4)；

(2) 服务器收到这个FIN，发回一个ACK，确认序号为收到的序号加1(报文段5)。和SYN一样，一个FIN将占用一个序号；

(3) 服务器关闭客户端的连接后，再发送一个FIN给客户端(报文段6)；

(4) 客户段收到服务端的FIN后，发回ACK报文确认，并将确认序号设置为收到序号加1(报文段7)；

注意：TCP连接的任何一方都可以发起挥手操作，上述步骤只是两种之一；



### 为什么是“四次挥手”？

因为当收到对方的FIN报文通知时，它仅仅表示对方没有数据发送给你了；但**未必你所有的数据都全部发送给对方**了，所以你可能还需要发送一些数据给对方，再发送FIN报文给对方来表示你同意现在可以关闭连接了，故这里的ACK报文和FIN报文多数情况下都是分开发送的，也就造成了4次挥手。

>   服务端还有未发送的数据给客户端

## 握手，挥手过程中各状态

（1）3次握手过程状态：

- LISTEN: 这个也是非常容易理解的一个状态，表示服务器端的某个SOCKET处于监听状态，可以接受连接了。

- SYN_SENT: 当客户端SOCKET执行CONNECT连接时，它首先发送SYN报文，因此也随即它会进入到了SYN_SENT状态，并等待服务端的发送三次握手中的第2个报文。SYN_SENT状态表示客户端已发送SYN报文。(发送端)

- SYN_RCVD: 这个状态与SYN_SENT遥想呼应这个状态表示接受到了SYN报文，在正常情况下，这个状态是服务器端的SOCKET在建立TCP连接时的三次握手会话过程中的一个中间状态，很短暂，基本上用netstat你是很难看到这种状态的，除非你特意写了一个客户端测试程序，故意将三次TCP握手过程中最后一个ACK报文不予发送。因此这种状态时，当收到客户端的ACK报文后，它会进入到ESTABLISHED状态。(服务器端)

- ESTABLISHED：这个容易理解了，表示连接已经建立了。

（2）4次挥手过程状态：

- FIN_WAIT_1: 这个状态要好好解释一下，其实FIN_WAIT_1和FIN_WAIT_2状态的真正含义都是表示等待对方的FIN报文。而这两种状态的区别是：FIN_WAIT_1状态实际上是当SOCKET在ESTABLISHED状态时，它想主动关闭连接，向对方发送了FIN报文，此时该SOCKET即进入到FIN_WAIT_1状态。而当对方回应ACK报文后，则进入到FIN_WAIT_2状态，当然在实际的正常情况下，无论对方何种情况下，都应该马上回应ACK报文，所以FIN_WAIT_1状态一般是比较难见到的，而FIN_WAIT_2状态还有时常常可以用netstat看到。(主动方)

- FIN_WAIT_2：上面已经详细解释了这种状态，实际上FIN_WAIT_2状态下的SOCKET，表示半连接，也即有一方要求close连接，但另外还告诉对方，我暂时还有点数据需要传送给你(ACK信息)，稍后再关闭连接。(主动方)

- TIME_WAIT: 表示收到了对方的FIN报文，并发送出了ACK报文，就等2MSL后即可回到CLOSED可用状态了。如果FIN_WAIT_1状态下，收到了对方同时带FIN标志和ACK标志的报文时，可以直接进入到TIME_WAIT状态，而无须经过FIN_WAIT_2状态。(主动方)

- CLOSING(比较少见): 这种状态比较特殊，实际情况中应该是很少见，属于一种比较罕见的例外状态。正常情况下，当你发送FIN报文后，按理来说是应该先收到(或同时收到)对方的ACK报文，再收到对方的FIN报文。但是CLOSING状态表示你发送FIN报文后，并没有收到对方的ACK报文，反而却也收到了对方的FIN报文。什么情况下会出现此种情况呢?其实细想一下，也不难得出结论：那就是如果双方几乎在同时close一个SOCKET的话，那么就出现了双方同时发送FIN报文的情况，也即会出现CLOSING状态，表示双方都正在关闭SOCKET连接。

- CLOSE_WAIT: 这种状态的含义其实是表示在等待关闭。怎么理解呢?当对方close一个SOCKET后发送FIN报文给自己，你系统毫无疑问地会回应一个ACK报文给对方，此时则进入到CLOSE_WAIT状态。接下来呢，实际上你真正需要考虑的事情是察看你是否还有数据发送给对方，如果没有的话，那么你也就可以close这个SOCKET，发送FIN报文给对方，也即关闭连接。所以你在CLOSE_WAIT状态下，需要完成的事情是等待你去关闭连接。(被动方)

- LAST_ACK: 这个状态还是比较容易好理解的，它是被动关闭一方在发送FIN报文后，最后等待对方的ACK报文。当收到ACK报文后，也即可以进入到CLOSED可用状态了。(被动方)



## TCP/UDP区别





## HTTP和HTTPS区别

HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

HTTPS（Secure Hypertext Transfer Protocol）安全超文本传输协议，与http主要区别在于：

-   http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议；
-   http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443；

下面具体介绍一下HTTP和HTTPS协议：

首先说明一下：HTTP和HTTPS协议是应用层协议；



HTTPS协议、SSL、和数字证书的关系介绍：

概述：对于HTTPS协议，所有的消息都是经过SSL协议方式加密，而支持加密的文件正是数字证书；

（1）SSL

SSL常用的加密算法：对称密码算法、非对称密码算法、散列算法；

SSL的加密过程：需要注意的是非对称加解密算法的效率要比对称加解密要低的多。所以SSL在握手过程中使用非对称密码算法来

协商密钥，实际使用对称加解密的方法对http内容加密传输；

（2）数字证书

数字证书是用于在INTERNET上标识个人或者机构身份的一种技术手段，它通过由一些公认的权威机构所认证，从而可以保证其

安全地被应用在各种场合。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。

### 常见的非对称加密技术





## TCP超时等待、重传以及流量控制

>TCP等待时间需要设定，超过了就认为丢包，需要重传；
>
>为了防止拥塞情况，一般会采用流量控制，其实现手段是用滑动窗口限制客户端发送分组数量；





## 键入`www.baidu.com`到网页显示发生了什么



1.   浏览器解析URL, 
2.   根据解析到的信息生成 HTTP 请求消息
3.   **查询服务器域名对应的 IP 地址**, 委托操作系统将消息发送给 `Web` 服务器
4.   





# OS篇

## 五大IO模型

-   BIO: 阻塞 `I/O`（`blocking IO`）
-   NIO: 非阻塞 `I/O`（`nonblocking IO`）
-   `I/O` 多路复用（ `IO multiplexing`）
-   信号驱动 `I/O`（ `signal driven IO`）
-   AIO: 异步 `I/O`（`asynchronous IO`）



## epoll的工作原理

红黑树





## 什么是惊群现象，怎么解决

**惊群问题**是计算机科学中，当许多进程等待一个事件，事件发生后这些进程被唤醒，但只有一个进程能获得CPU执行权，其他进程又得被阻塞，这造成了严重的系统上下文切换代价。

解决办法可能有：

1.  不希望把所有进程都唤醒，就采用定点唤醒某一个进程的做法。
2.  尽量避免进程上下文切换。

C10K问题（Concurrent 10,000 Connections），指服务器同时支持上万个客户端连接的问题。可用Linux的epoll，FreeBSD的kqueue，Solaris的/dev/poll来解决。

C10M问题，是千万级并发实现。Linux上通常用epoll实现。





# 并发篇



## 进程间通信方式

- 管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

- 信号量( semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

- 消息队列( message queue ) ：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

- 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

- 套接字( socket ) ：套解口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。

## 线程间通信方式

- 全局变量；
- Messages消息机制；
- CEvent对象（MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）。

## 死锁

下面四个条件都成立才发生死锁:

-   互斥条件: 多个线程不能同时使用一个资源
-   持有并等待条件: 线程已经持有的线程被别的线程访问, 别的线程只能阻塞
-   不可剥夺条件: 自己使用完资源之前, 资源不会被别的线程获取
-   环路等待条件: 两个(或多个)线程获取资源的顺序存在环路



## 协程

>   定义：协程是一种用户态的轻量级线程。
>
>   协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置；
>
>   线程是抢占式，而协程是协作式；
>
>   协程的优点：
>
>   -   跨平台
>   -   跨体系架构
>   -   无需线程上下文切换的开销
>   -   无需原子操作锁定及同步的开销
>   -   方便切换控制流，简化编程模型
>   -   高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。
>
>   协程的缺点：
>
>   无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU；
>
>   进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决。









