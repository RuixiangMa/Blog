---
categories: [forJobs]
tags: Interview Linux
---

# 内存





## 内存分页





## 内存映射/共享内存



### 匿名映射



### 文件映射





## 虚拟内存

### 概念





# CPU

## 基本概念





## 调度算法



### 先来先服务



### 最短作业优先



### 高优先级



### 时间片轮转: Round Robin



### 总结与比较







## 作业和进程的区别

作业是用户提交给系统的一个任务，在用户向计算机提交作业后，系统将它放入外存中的作业等待队列中等待执行。而进程则是完成用户任务的执行实体，是向系统申请分配资源的基本单位。任一进程，只要它被创建，总有相应的部分存在于内存中。

-   一个作业通常包括几个进程，几个进程共同完成一个任务，且必须至少由一个进程组成。
-   用户提交作业以后，当作业被调度，系统会为作业创建进程，一个进程无法完成时，系统会为这个进程创建子进程。
-   作业与进程最主要的区别是：前者是由用户提交，后者是由系统自动生成；前者以用户任务为单位，后者是操作系统控制的单位。





# 缓存

什么是缓存?

## 缓存控制策略



### LRU







### LFU















# 五大IO模型

-   阻塞 `I/O`（`blocking IO`）
-   非阻塞 `I/O`（`nonblocking IO`）
-   `I/O` 多路复用（ `IO multiplexing`）
-   信号驱动 `I/O`（ `signal driven IO`）
-   异步 `I/O`（`asynchronous IO`）



## epoll的工作原理







## 什么是惊群现象，怎么解决

**惊群问题**是 当许多进程等待一个事件，事件发生后这些进程被唤醒，但只有一个进程能获得CPU执行权，其他进程又得被阻塞，这造成了严重的系统上下文切换代价。

解决办法可能有：

1.  不希望把所有进程都唤醒，就采用定点唤醒某一个进程的做法。
2.  尽量避免进程上下文切换。

C10K问题（Concurrent 10,000 Connections），指服务器同时支持上万个客户端连接的问题。可用Linux的epoll，FreeBSD的kqueue，Solaris的/dev/poll来解决。

C10M问题，是千万级并发实现。Linux上通常用epoll实现。





# 并发-进程/线程管理



## 进程间通信方式

- 管道( pipe, 匿名管道/命名管道)：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。

- 信号量( semophore ) ：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。

- 消息队列( message queue ) ：消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

- 共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。

- 套接字( socket ) ：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同及其间的进程通信。



## 线程间通信方式

- 全局变量；
- Messages消息机制；
- CEvent对象（Windows-MFC中的一种线程通信对象，通过其触发状态的改变实现同步与通信）。



## 死锁

### 条件

下面四个条件都成立才发生死锁:

-   互斥条件: 多个线程不能同时使用一个资源
-   持有并等待条件: 线程已经持有的线程被别的线程访问, 别的线程只能阻塞
-   不可剥夺条件: 自己使用完资源之前, 资源不会被别的线程获取
-   环路等待条件: 两个(或多个)线程获取资源的顺序存在环路



## 协程: 用户级线程

>   定义：协程是一种用户态的轻量级线程。
>
>   协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置；
>
>   线程是抢占式，而协程是协作式；
>

### 优点

>   -   跨平台
>-   跨体系架构
>   -   无需线程上下文切换的开销
>-   无需原子操作锁定及同步的开销
>   -   方便切换控制流，简化编程模型
>-   高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。
>   

### 缺点

>   无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU；
>
>   进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序：这一点和事件驱动一样，可以使用异步IO操作来解决。









